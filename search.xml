<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Test: Hello World!</title>
    <url>/2020/08/17/Test-Hello-World/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><h2 id="这是一次测试！"><a href="#这是一次测试！" class="headerlink" title="这是一次测试！"></a>这是一次测试！</h2><p>To be continue…</p>
]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title>jsDelivr+GitHub+PicGo搭建免费图床</title>
    <url>/2020/09/15/FigureBed/</url>
    <content><![CDATA[<h2 id="一、概念简介"><a href="#一、概念简介" class="headerlink" title="一、概念简介"></a>一、概念简介</h2><h3 id="1-图床"><a href="#1-图床" class="headerlink" title="1.图床"></a>1.图床</h3><blockquote>
<p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。简而言之，就是能提供一些可以把图片存放到网上并且引用到其他网站使用的服务。</p>
</blockquote>
<h3 id="2-CDN"><a href="#2-CDN" class="headerlink" title="2.CDN"></a>2.CDN</h3><blockquote>
<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
</blockquote>
<h3 id="3-jsDelivr"><a href="#3-jsDelivr" class="headerlink" title="3.jsDelivr"></a>3.jsDelivr</h3><blockquote>
<p>jsDelivr 是一个提供含JavaScript库、jQuery插件、CSS框架、字体等Web上常用静态资源的免费开源的 CDN 解决方案。其采用全球CDN加速，确保每个地区的使用者都能获得最好的连接速度，而在大陆地区使用了国内的CDN加速。因此jsDelivr在大陆也有很好的响应速度，jsDelivr可将不同的JavaScript或CSS libraries集合在一起使用，同时，jsDelivr也提供包括npm、GitHub、WordPress等项目的镜像服务。</p>
</blockquote>
<h3 id="4-Github"><a href="#4-Github" class="headerlink" title="4.Github"></a>4.Github</h3><blockquote>
<p>GitHub 是一个面向开源及私有软件项目的托管平台。额，这个不必多说。</p>
</blockquote>
<h3 id="5-PicGo"><a href="#5-PicGo" class="headerlink" title="5.PicGo"></a>5.PicGo</h3><blockquote>
<p>PicGo 是一款开源跨平台的免费图片上传工具以及图床相册管理软件，它能帮你快速地将图片上传到微博、又拍云、阿里云 OSS、腾讯云 COS、七牛、GitHub、sm.ms、Imgur 等常见的免费图床网站或云存储服务上，并自动复制图片的链接到剪贴板里，使用起来高效便捷。<a href="https://github.com/Molunerfinn/PicGo/releases">下载地址</a></p>
</blockquote>
<h2 id="二、搭建步骤"><a href="#二、搭建步骤" class="headerlink" title="二、搭建步骤"></a>二、搭建步骤</h2><h3 id="1-新建图床仓库"><a href="#1-新建图床仓库" class="headerlink" title="1.新建图床仓库"></a>1.新建图床仓库</h3><p>在github上新建一个仓库，作为图床仓库。<br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tldmluQ2h1MTk5OC9GaWd1cmVCZWQvQmxvZ1BpYy9ibG9nMjAyMDA3MzBfZmlndXJlYmVkXzAwMS5wbmc?x-oss-process=image/format,png"></p>
<h3 id="2-新建一个访问令牌-access-token"><a href="#2-新建一个访问令牌-access-token" class="headerlink" title="2.新建一个访问令牌(access token)"></a>2.新建一个访问令牌(access token)</h3><p>在github上点击Settings&gt;&gt; Developer settings &gt;&gt; Personal access tokens &gt;&gt; Generate new token ，勾选repo项，然后点击Generate token生成一个token。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tldmluQ2h1MTk5OC9GaWd1cmVCZWQvQmxvZ1BpYy9ibG9nMjAyMDA3MzBfZmlndXJlYmVkXzAwMi5wbmc?x-oss-process=image/format,png"><br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tldmluQ2h1MTk5OC9GaWd1cmVCZWQvQmxvZ1BpYy9ibG9nMjAyMDA3MzBfZmlndXJlYmVkXzAwMy5wbmc?x-oss-process=image/format,png"></p>
<p>需要记录一下这个token（先不着急关闭该页面，这个token只会显示一次），在后面配置PicGo时候会用到。<br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tldmluQ2h1MTk5OC9GaWd1cmVCZWQvQmxvZ1BpYy9ibG9nMjAyMDA3MzBfZmlndXJlYmVkXzAwNC5wbmc?x-oss-process=image/format,png"></p>
<h3 id="3-配置PicGo"><a href="#3-配置PicGo" class="headerlink" title="3.配置PicGo"></a>3.配置PicGo</h3><p>首先下载安装完PicGo（<a href="https://github.com/Molunerfinn/PicGo/releases">下载地址</a>）。<br>打开并配置picgo，图床设置&gt;&gt;GitHub图床：<br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tldmluQ2h1MTk5OC9GaWd1cmVCZWQvQmxvZ1BpYy9ibG9nMjAyMDA3MzBfZmlndXJlYmVkXzAwNS5wbmc?x-oss-process=image/format,png"><br><strong>设定仓库名</strong>： 格式为：用户名 / 图床仓库名<br><strong>设定分支名</strong>： master<br><strong>设定Token</strong>： 之前创建的Token<br><strong>指定存储路径</strong>： 在仓库里的路径，如【BlogPic/】，即会在仓库里新建一个名为BlogPic的文件夹来存放上传的图片。<br> <strong>设定自定义域名</strong>：此处填写的内容会决定你的图片的访问链接，你上传的图片之后可以通过【此处填写的内容/图片路径】的形式来访问（图片路径指仓库里的存储文件夹/图片名称）。由于图片是上传到GitHub仓库中的，所以图片路径理应是【https：//github.com/用户名/仓库名/文件夹名/图片名】，但我们还需要通过免费的CDN——JSDelivr来加速图片（jsDelivr 提供加速 GitHub 仓库的域名 cdn.jsdelivr.net/gh），故此处应填写成【https：//cdn.jsdelivr.net/gh/用户名/图床仓库名】。之后便可通过【https：//cdn.jsdelivr.net/gh/用户名/图床仓库名/文件夹名/图片名】来加速访问图片。</p>
<h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="1-上传图片"><a href="#1-上传图片" class="headerlink" title="1.上传图片"></a>1.上传图片</h3><p>按照以上步骤配置完成以后，可以直接将需要上传的本地图片拖进PicGo的上传区，即可将该图片上传至GitHub图床仓库的存储文件夹内。<br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tldmluQ2h1MTk5OC9GaWd1cmVCZWQvQmxvZ1BpYy9ibG9nMjAyMDA3MzBfZmlndXJlYmVkXzAwNi5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h3 id="2-使用链接访问图片"><a href="#2-使用链接访问图片" class="headerlink" title="2.使用链接访问图片"></a>2.使用链接访问图片</h3><p>可以在PicGo的相册里快捷获得最近上传的图片的链接复制，或者通过【https：//cdn.jsdelivr.net/gh/用户名/图床仓库名/文件夹名/图片名】的方式访问图片或将其引用至博客等需要使用的地方。<br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tldmluQ2h1MTk5OC9GaWd1cmVCZWQvQmxvZ1BpYy9ibG9nMjAyMDA3MzBfZmlndXJlYmVkXzAwNy5wbmc?x-oss-process=image/format,png"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>PicGo</tag>
        <tag>jsDelivr</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>设计模式简介</title>
    <url>/2020/10/10/DesignPatterns/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式是一套被反复使用、经过分类编目的代码设计经验的总结。使用设计模式是为了复用成功的设计和体系结构、复用相似</p>
<p>问题的相同解决方案，保证代码可靠性，使代码编制真正工程化，能够适应需求的变化。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>23 种设计模式，描述如下：</p>
<h4 id="1-抽象工厂-Abstract-Factory-。"><a href="#1-抽象工厂-Abstract-Factory-。" class="headerlink" title="1.抽象工厂(Abstract Factory)。"></a>1.抽象工厂(Abstract Factory)。</h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h4 id="2-工厂方法-Factory-Method-。"><a href="#2-工厂方法-Factory-Method-。" class="headerlink" title="2.工厂方法(Factory Method)。"></a>2.工厂方法(Factory Method)。</h4><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化,工厂方法使一个类的实例化延迟到其子类。</p>
<h4 id="3-适配器-Adapter-。"><a href="#3-适配器-Adapter-。" class="headerlink" title="3.适配器(Adapter)。"></a>3.适配器(Adapter)。</h4><p>将一个类的接口转换成客户希望的另外一个接口。 adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h4 id="4-桥接-Bridge-。"><a href="#4-桥接-Bridge-。" class="headerlink" title="4.桥接(Bridge)。"></a>4.桥接(Bridge)。</h4><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。对实现部分的修改不会影响到使用它们的程序。</p>
<h4 id="5-建造者-Builder-。"><a href="#5-建造者-Builder-。" class="headerlink" title="5.建造者(Builder)。"></a>5.建造者(Builder)。</h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h4 id="6-责任链-Chain-of-Responsibility-。"><a href="#6-责任链-Chain-of-Responsibility-。" class="headerlink" title="6.责任链(Chain of Responsibility)。"></a>6.责任链(Chain of Responsibility)。</h4><p>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p>
<h4 id="7-命令-Command-。"><a href="#7-命令-Command-。" class="headerlink" title="7.命令(Command)。"></a>7.命令(Command)。</h4><p>将一个请求封装为一个对象，从而使我们可用不同的请求对象进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作；命令模式将调用操作的请求对象与知道如何实现该操作的接收对象解耦。</p>
<h4 id="8-组合-Composite-。"><a href="#8-组合-Composite-。" class="headerlink" title="8.组合(Composite)。"></a>8.组合(Composite)。</h4><p>将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</p>
<h4 id="9-装饰-Decorator-。"><a href="#9-装饰-Decorator-。" class="headerlink" title="9.装饰(Decorator)。"></a>9.装饰(Decorator)。</h4><p>动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。</p>
<h4 id="10-外观模式-Facade-。"><a href="#10-外观模式-Facade-。" class="headerlink" title="10.外观模式(Facade)。"></a>10.外观模式(Facade)。</h4><p>为子系统中的一组接口提供一个一致的界面， Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<h4 id="11-享元-Flyweight-。"><a href="#11-享元-Flyweight-。" class="headerlink" title="11.享元(Flyweight)。"></a>11.享元(Flyweight)。</h4><p>运用共享技术有效地支持大量细粒度的对象。</p>
<h4 id="12-解释器-Interpreter-。"><a href="#12-解释器-Interpreter-。" class="headerlink" title="12.解释器(Interpreter)。"></a>12.解释器(Interpreter)。</h4><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p>
<h4 id="13-迭代-Iterator-。"><a href="#13-迭代-Iterator-。" class="headerlink" title="13.迭代(Iterator)。"></a>13.迭代(Iterator)。</h4><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p>
<h4 id="14-中介者-Mediator-。"><a href="#14-中介者-Mediator-。" class="headerlink" title="14.中介者(Mediator)。"></a>14.中介者(Mediator)。</h4><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<h4 id="15-备忘录-Memento-。"><a href="#15-备忘录-Memento-。" class="headerlink" title="15.备忘录(Memento)。"></a>15.备忘录(Memento)。</h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>
<h4 id="16-观察者-Observer-。"><a href="#16-观察者-Observer-。" class="headerlink" title="16.观察者(Observer)。"></a>16.观察者(Observer)。</h4><p>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</p>
<h4 id="17-原型-Prototype-。"><a href="#17-原型-Prototype-。" class="headerlink" title="17.原型(Prototype)。"></a>17.原型(Prototype)。</h4><p>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p>
<h4 id="18-代理-Proxy-。"><a href="#18-代理-Proxy-。" class="headerlink" title="18.代理(Proxy)。"></a>18.代理(Proxy)。</h4><p>为其他对象提供一个代理以控制对这个对象的访问。</p>
<h4 id="19-单例-Singleton-。"><a href="#19-单例-Singleton-。" class="headerlink" title="19.单例(Singleton)。"></a>19.单例(Singleton)。</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。看起来似乎修改了它所属的类。</p>
<h4 id="21-策略-Strategy-。"><a href="#21-策略-Strategy-。" class="headerlink" title="21.策略(Strategy)。"></a>21.策略(Strategy)。</h4><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p>
<h4 id="22-模板方法-Template-Method-。"><a href="#22-模板方法-Template-Method-。" class="headerlink" title="22.模板方法(Template Method)。"></a>22.模板方法(Template Method)。</h4><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<h4 id="23-访问者-Visitor-。"><a href="#23-访问者-Visitor-。" class="headerlink" title="23.访问者(Visitor)。"></a>23.访问者(Visitor)。</h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>设计模式默认可分为3大类如下：</p>
<h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><p>单独对对象的创建进行研究，从而能够高效地创建对象。包含 6 个设计模式：简单工厂模式（ SimpleFactory）、工厂方法模式（ Factory Method）、抽象工厂模式（ Abstract Factory）、创建者模式（ Builder）、原型模式（ Prototype）、单例模式（ Singleton）。</p>
<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><p>研究对象的组成以及对象之间的依赖关系，如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。有 7 个具体的结构型模式可供研究，它们分别是：外观模式（ Facade）、适配器模式（ Adapter）、代理模式（ Proxy）、装饰模式（ Decorator）、桥接模式（ Bridge）、组合模式（ Composite）、享元模式（ Flyweight）。</p>
<h4 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h4><p>对对象的行为进行研究，它们分别是：模板方法模式（ Template Method）、观察者模式Observer）、状态模式（ State）、策略模式（ Strategy）、职责链模式（ Chain of Responsibility）、命令模式（ Command）、访问者模式（ Visitor）、调停者模式（ Mediator）、备忘录模式（ Memento）、迭代器模式（ Iterator）、 解释器模式（ Interpreter）。</p>
<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><p>设计模式的六大原则<br>总原则：开闭原则（Open Close Principle）<br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p>
<h4 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h4><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p>
<h4 id="2、里氏替换原则（Liskov-Substitution-Principle）"><a href="#2、里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏替换原则（Liskov Substitution Principle）"></a>2、里氏替换原则（Liskov Substitution Principle）</h4><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<p>里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>
<h4 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h4><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
<h4 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h4><p>这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p>
<h4 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h4><p>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p>
<h4 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h4><p>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题汇总</title>
    <url>/2020/10/18/Java/</url>
    <content><![CDATA[<h2 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h2><h3 id="一、Java-基础"><a href="#一、Java-基础" class="headerlink" title="一、Java 基础"></a>一、Java 基础</h3><p>1.JDK 和 JRE 有什么区别？</p>
<p>2.== 和 equals 的区别是什么？</p>
<p>3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</p>
<p>4.final 在 java 中有什么作用？</p>
<p>5.java 中的 Math.round(-1.5) 等于多少？</p>
<p>6.String 属于基础的数据类型吗？</p>
<p>7.java 中操作字符串都有哪些类？它们之间有什么区别？</p>
<p>8.String str=”i”与 String str=new String(“i”)一样吗？</p>
<p>9.如何将字符串反转？</p>
<p>10.String 类的常用方法都有那些？</p>
<p>11.抽象类必须要有抽象方法吗？</p>
<p>12.普通类和抽象类有哪些区别？</p>
<p>13.抽象类能使用 final 修饰吗？</p>
<p>14.接口和抽象类有什么区别？</p>
<p>15.java 中 IO 流分为几种？</p>
<p>16.BIO、NIO、AIO 有什么区别？</p>
<p>17.Files的常用方法都有哪些？</p>
<h3 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h3><p>18.java 容器都有哪些？</p>
<p>19.Collection 和 Collections 有什么区别？</p>
<p>20.List、Set、Map 之间的区别是什么？</p>
<p>21.HashMap 和 Hashtable 有什么区别？</p>
<p>22.如何决定使用 HashMap 还是 TreeMap？</p>
<p>23.说一下 HashMap 的实现原理？</p>
<p>24.说一下 HashSet 的实现原理？</p>
<p>25.ArrayList 和 LinkedList 的区别是什么？</p>
<p>26.如何实现数组和 List 之间的转换？</p>
<p>27.ArrayList 和 Vector 的区别是什么？</p>
<p>28.Array 和 ArrayList 有何区别？</p>
<p>29.在 Queue 中 poll()和 remove()有什么区别？</p>
<p>30.哪些集合类是线程安全的？</p>
<p>31.迭代器 Iterator 是什么？</p>
<p>32.Iterator 怎么使用？有什么特点？</p>
<p>33.Iterator 和 ListIterator 有什么区别？</p>
<p>34.怎么确保一个集合不能被修改？</p>
<h3 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h3><p>35.并行和并发有什么区别？</p>
<p>36.线程和进程的区别？</p>
<p>37.守护线程是什么？</p>
<p>38.创建线程有哪几种方式？</p>
<p>39.说一下 runnable 和 callable 有什么区别？</p>
<p>40.线程有哪些状态？</p>
<p>41.sleep() 和 wait() 有什么区别？</p>
<p>42.notify()和 notifyAll()有什么区别？</p>
<p>43.线程的 run()和 start()有什么区别？</p>
<p>44.创建线程池有哪几种方式？</p>
<p>45.线程池都有哪些状态？</p>
<p>46.线程池中 submit()和 execute()方法有什么区别？</p>
<p>47.在 java 程序中怎么保证多线程的运行安全？</p>
<p>48.多线程锁的升级原理是什么？</p>
<p>49.什么是死锁？</p>
<p>50.怎么防止死锁？</p>
<p>51.ThreadLocal 是什么？有哪些使用场景？</p>
<p>52.说一下 synchronized 底层实现原理？</p>
<p>53.synchronized 和 volatile 的区别是什么？</p>
<p>54.synchronized 和 Lock 有什么区别？</p>
<p>55.synchronized 和 ReentrantLock 区别是什么？</p>
<p>56.说一下 atomic 的原理？</p>
<h3 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h3><p>57.什么是反射？</p>
<p>58.什么是 java 序列化？什么情况下需要序列化？</p>
<p>59.动态代理是什么？有哪些应用？</p>
<p>60.怎么实现动态代理？</p>
<h3 id="五、对象拷贝"><a href="#五、对象拷贝" class="headerlink" title="五、对象拷贝"></a>五、对象拷贝</h3><p>61.为什么要使用克隆？</p>
<p>62.如何实现对象克隆？</p>
<p>63.深拷贝和浅拷贝区别是什么？</p>
<h3 id="六、Java-Web"><a href="#六、Java-Web" class="headerlink" title="六、Java Web"></a>六、Java Web</h3><p>64.jsp 和 servlet 有什么区别？</p>
<p>65.jsp 有哪些内置对象？作用分别是什么？</p>
<p>66.说一下 jsp 的 4 种作用域？</p>
<p>67.session 和 cookie 有什么区别？</p>
<p>68.说一下 session 的工作原理？</p>
<p>69.如果客户端禁止 cookie 能实现 session 还能用吗？</p>
<p>70.spring mvc 和 struts 的区别是什么？</p>
<p>71.如何避免 sql 注入？</p>
<p>72.什么是 XSS 攻击，如何避免？</p>
<p>73.什么是 CSRF 攻击，如何避免？</p>
<h3 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h3><p>74.throw 和 throws 的区别？</p>
<p>75.final、finally、finalize 有什么区别？</p>
<p>76.try-catch-finally 中哪个部分可以省略？</p>
<p>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</p>
<p>78.常见的异常类有哪些？</p>
<h3 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h3><p>79.http 响应码 301 和 302 代表的是什么？有什么区别？</p>
<p>80.forward 和 redirect 的区别？</p>
<p>81.简述 tcp 和 udp的区别？</p>
<p>82.tcp 为什么要三次握手，两次不行吗？为什么？</p>
<p>83.说一下 tcp 粘包是怎么产生的？</p>
<p>84.OSI 的七层模型都有哪些？</p>
<p>85.get 和 post 请求有哪些区别？</p>
<p>86.如何实现跨域？</p>
<p>87.说一下 JSONP 实现原理？</p>
<h3 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h3><p>88.说一下你熟悉的设计模式？</p>
<p>89.简单工厂和抽象工厂有什么区别？</p>
<h3 id="十、Spring-Spring-MVC"><a href="#十、Spring-Spring-MVC" class="headerlink" title="十、Spring/Spring MVC"></a>十、Spring/Spring MVC</h3><p>90.为什么要使用 spring？</p>
<p>91.解释一下什么是 aop？</p>
<p>92.解释一下什么是 ioc？</p>
<p>93.spring 有哪些主要模块？</p>
<p>94.spring 常用的注入方式有哪些？</p>
<p>95.spring 中的 bean 是线程安全的吗？</p>
<p>96.spring 支持几种 bean 的作用域？</p>
<p>97.spring 自动装配 bean 有哪些方式？</p>
<p>98.spring 事务实现方式有哪些？</p>
<p>99.说一下 spring 的事务隔离？</p>
<p>100.说一下 spring mvc 运行流程？</p>
<p>101.spring mvc 有哪些组件？</p>
<p>102.@RequestMapping 的作用是什么？</p>
<p>103.@Autowired 的作用是什么？</p>
<h3 id="十一、Spring-Boot-Spring-Cloud"><a href="#十一、Spring-Boot-Spring-Cloud" class="headerlink" title="十一、Spring Boot/Spring Cloud"></a>十一、Spring Boot/Spring Cloud</h3><p>104.什么是 spring boot？</p>
<p>105.为什么要用 spring boot？</p>
<p>106.spring boot 核心配置文件是什么？</p>
<p>107.spring boot 配置文件有哪几种类型？它们有什么区别？</p>
<p>108.spring boot 有哪些方式可以实现热部署？</p>
<p>109.jpa 和 hibernate 有什么区别？</p>
<p>110.什么是 spring cloud？</p>
<p>111.spring cloud 断路器的作用是什么？</p>
<p>112.spring cloud 的核心组件有哪些？</p>
<h3 id="十二、Hibernate"><a href="#十二、Hibernate" class="headerlink" title="十二、Hibernate"></a>十二、Hibernate</h3><p>113.为什么要使用 hibernate？</p>
<p>114.什么是 ORM 框架？</p>
<p>115.hibernate 中如何在控制台查看打印的 sql 语句？</p>
<p>116.hibernate 有几种查询方式？</p>
<p>117.hibernate 实体类可以被定义为 final 吗？</p>
<p>118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？</p>
<p>119.hibernate 是如何工作的？</p>
<p>120.get()和 load()的区别？</p>
<p>121.说一下 hibernate 的缓存机制？</p>
<p>122.hibernate 对象有哪些状态？</p>
<p>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</p>
<p>124.hibernate 实体类必须要有无参构造函数吗？为什么？</p>
<h3 id="十三、Mybatis"><a href="#十三、Mybatis" class="headerlink" title="十三、Mybatis"></a>十三、Mybatis</h3><p>125.mybatis 中 #{}和 ${}的区别是什么？</p>
<p>126.mybatis 有几种分页方式？</p>
<p>127.RowBounds 是一次性查询全部结果吗？为什么？</p>
<p>128.mybatis 逻辑分页和物理分页的区别是什么？</p>
<p>129.mybatis 是否支持延迟加载？延迟加载的原理是什么？</p>
<p>130.说一下 mybatis 的一级缓存和二级缓存？</p>
<p>131.mybatis 和 hibernate 的区别有哪些？</p>
<p>132.mybatis 有哪些执行器（Executor）？</p>
<p>133.mybatis 分页插件的实现原理是什么？</p>
<p>134.mybatis 如何编写一个自定义插件？</p>
<h3 id="十四、RabbitMQ"><a href="#十四、RabbitMQ" class="headerlink" title="十四、RabbitMQ"></a>十四、RabbitMQ</h3><p>135.rabbitmq 的使用场景有哪些？</p>
<p>136.rabbitmq 有哪些重要的角色？</p>
<p>137.rabbitmq 有哪些重要的组件？</p>
<p>138.rabbitmq 中 vhost 的作用是什么？</p>
<p>139.rabbitmq 的消息是怎么发送的？</p>
<p>140.rabbitmq 怎么保证消息的稳定性？</p>
<p>141.rabbitmq 怎么避免消息丢失？</p>
<p>142.要保证消息持久化成功的条件有哪些？</p>
<p>143.rabbitmq 持久化有什么缺点？</p>
<p>144.rabbitmq 有几种广播类型？</p>
<p>145.rabbitmq 怎么实现延迟消息队列？</p>
<p>146.rabbitmq 集群有什么用？</p>
<p>147.rabbitmq 节点的类型有哪些？</p>
<p>148.rabbitmq 集群搭建需要注意哪些问题？</p>
<p>149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</p>
<p>150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</p>
<p>151.rabbitmq 对集群节点停止顺序有要求吗？</p>
<h3 id="十五、Kafka"><a href="#十五、Kafka" class="headerlink" title="十五、Kafka"></a>十五、Kafka</h3><p>152.kafka 可以脱离 zookeeper 单独使用吗？为什么？</p>
<p>153.kafka 有几种数据保留的策略？</p>
<p>154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</p>
<p>155.什么情况会导致 kafka 运行变慢？</p>
<p>156.使用 kafka 集群需要注意什么？</p>
<h3 id="十六、Zookeeper"><a href="#十六、Zookeeper" class="headerlink" title="十六、Zookeeper"></a>十六、Zookeeper</h3><p>157.zookeeper 是什么？</p>
<p>158.zookeeper 都有哪些功能？</p>
<p>159.zookeeper 有几种部署模式？</p>
<p>160.zookeeper 怎么保证主从节点的状态同步？</p>
<p>161.集群中为什么要有主节点？</p>
<p>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</p>
<p>163.说一下 zookeeper 的通知机制？</p>
<h3 id="十七、MySql"><a href="#十七、MySql" class="headerlink" title="十七、MySql"></a>十七、MySql</h3><p>164.数据库的三范式是什么？</p>
<p>165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</p>
<p>166.如何获取当前数据库版本？</p>
<p>167.说一下 ACID 是什么？</p>
<p>168.char 和 varchar 的区别是什么？</p>
<p>169.float 和 double 的区别是什么？</p>
<p>170.mysql 的内连接、左连接、右连接有什么区别？</p>
<p>171.mysql 索引是怎么实现的？</p>
<p>172.怎么验证 mysql 的索引是否满足需求？</p>
<p>173.说一下数据库的事务隔离？</p>
<p>174.说一下 mysql 常用的引擎？</p>
<p>175.说一下 mysql 的行锁和表锁？</p>
<p>176.说一下乐观锁和悲观锁？</p>
<p>177.mysql 问题排查都有哪些手段？</p>
<p>178.如何做 mysql 的性能优化？</p>
<h3 id="十八、Redis"><a href="#十八、Redis" class="headerlink" title="十八、Redis"></a>十八、Redis</h3><p>179.redis 是什么？都有哪些使用场景？</p>
<p>180.redis 有哪些功能？</p>
<p>181.redis 和 memecache 有什么区别？</p>
<p>182.redis 为什么是单线程的？</p>
<p>183.什么是缓存穿透？怎么解决？</p>
<p>184.redis 支持的数据类型有哪些？</p>
<p>185.redis 支持的 java 客户端都有哪些？</p>
<p>186.jedis 和 redisson 有哪些区别？</p>
<p>187.怎么保证缓存和数据库数据的一致性？</p>
<p>188.redis 持久化有几种方式？</p>
<p>189.redis 怎么实现分布式锁？</p>
<p>190.redis 分布式锁有什么缺陷？</p>
<p>191.redis 如何做内存优化？</p>
<p>192.redis 淘汰策略有哪些？</p>
<p>193.redis 常见的性能问题有哪些？该如何解决？</p>
<h3 id="十九、JVM"><a href="#十九、JVM" class="headerlink" title="十九、JVM"></a>十九、JVM</h3><p>194.说一下 jvm 的主要组成部分？及其作用？</p>
<p>195.说一下 jvm 运行时数据区？</p>
<p>196.说一下堆栈的区别？</p>
<p>197.队列和栈是什么？有什么区别？</p>
<p>198.什么是双亲委派模型？</p>
<p>199.说一下类加载的执行过程？</p>
<p>200.怎么判断对象是否可以被回收？</p>
<p>201.java 中都有哪些引用类型？</p>
<p>202.说一下 jvm 有哪些垃圾回收算法？</p>
<p>203.说一下 jvm 有哪些垃圾回收器？</p>
<p>204.详细介绍一下 CMS 垃圾回收器？</p>
<p>205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</p>
<p>206.简述分代垃圾回收器是怎么工作的？</p>
<p>207.说一下 jvm 调优的工具？</p>
<p>208.常用的 jvm 调优的参数都有哪些？</p>
<h2 id="答案汇总"><a href="#答案汇总" class="headerlink" title="答案汇总"></a>答案汇总</h2><p> <a href="https://blog.csdn.net/fangchao2011/article/details/89184058">基础模块</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89184615">容器</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89184943">多线程</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89185089">反射</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89186117">对象拷贝</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89185249">JavaWeb</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89185762">异常</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89185955">网络</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89185365">设计模式</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89186453">Spring/SpringMVC</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89186765">Spring Boot / Spring Cloud</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89186882">Hibernate</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89187435">Mybatis</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89187503">RabbitMQ</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89187544">Kafka</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89187599">Zookeeper</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89187694">MySql</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89360306">Redis</a><br> <a href="https://blog.csdn.net/fangchao2011/article/details/89360337">JVM</a><br> （参考自<a href="https://blog.csdn.net/jhl19981125/article/details/102757634%EF%BC%89">https://blog.csdn.net/jhl19981125/article/details/102757634）</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础总结</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>书摘1————《追风筝的人》</title>
    <url>/2020/09/28/BookExtracts001/</url>
    <content><![CDATA[<h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一次看这本书还是高中时候，和室友借了这本小说，看到一半，在教室被值班巡逻的老师没收了。隔天还给班主任痛骂了一顿。当时看得入迷，还没看到结局，于是被没收后立马想办法去附近书店买了本新的，看完后才还给了室友。</p>
</blockquote>
<h4 id="语句摘录："><a href="#语句摘录：" class="headerlink" title="语句摘录："></a>语句摘录：</h4><blockquote>
<p>1、为你，千千万万遍。<br>2、得到了再失去，总是比从来就没有得到更伤人。<br>3、我很高兴终于有人识破我的真面目，我装得太累了。<br>4、时间很贪婪——有时候，它会独自吞噬所有的细节。<br>5、一个不能为自己挺身而出的男孩，长大后只能是个懦夫。<br>6、在阿富汗，有很多儿童，却没有童年。<br>7、时间一秒一秒过去，而一秒与一秒之间，似乎隔着永恒。<br>8、我们总喜欢给自己找很多理由去解释自己的懦弱，总是自欺欺人的去相信那些美丽的谎言，总是去掩饰自己内心的恐惧，总是去逃避自己犯下的罪行。但事实总是，有一天，我们不得不坦然面对那些罪恶，给自己心灵予救赎。<br>9、被真相伤害，总比被谎言安慰要好。<br>10、孩子又不是图画练习册，你不能光顾着要涂上自己喜欢的色彩。<br>11、我们有什么权利，指责别人的过去。<br>12、没有良心，没有美德的人不会痛苦。<br>13、我们没有必要知道断线的风筝会飞到哪里去，甚至连它的影子都不值得去追随，只要你能为他付出真心，它一定就在你所追寻的方向。<br>14、罪行只有一种，只有一种，那就是盗窃，其他罪行都是盗窃的变种。<br>15、哈桑曾经深爱过我，以前无人那样待我，日后也永远不会有。<br>16、亲爱的阿米尔，当罪行导致善行，那就是真正的获救。<br>17、我的离开很久远了，久得足以遗忘，也足以被遗忘。<br>18、他真纯洁的该死，跟他在一起，你永远觉得自己是个骗子。<br>19、倘使恶魔仍在你脑中徘徊萦绕，前程又谈何说起呢？<br>20、有些事情比真相更重要。<br>21、我尖叫，尖叫卡在喉咙里。<br>22、我们是否知道我们心中的风筝到底在什么地方，人生错过就不会再得到，也许我们会忏悔，会救赎，但这些似乎都已经晚了，每当天空放飞起风筝的那一刻，我们是不是应该问问自己我们是否真的珍惜我们所拥有的一切。<br>23、我不记得那是何年何月的事情了。我只知道记忆与我同在，将美好的往事完美的浓缩起来，如同一笔浓墨重彩，涂抹在我们那已经变得灰白单调的生活画布上。<br>24、可是人就是这样，总会活在某个时限内，那里的世界也许是几年之后连自己都无法理解的，但这又是我们无法突破的。为你，千千万万遍，遍体鳞伤还是会义无反顾，也许这就是人生，人生不是只做值得的事情！<br>25、我们在人生的不同时期都会曾不惜一切去追逐当下最执着的想要得到的事物，它也许只是爸爸的专宠、兄弟的情谊、对那个一直暗恋的王子抑或公主的爱慕。。。所有的一切都有可能成为我们那时心中的风筝，我们奔跑着，一直向前，眼中心里想的都是它。可是当时光滚滚向前，我们是否发现曾经执着追寻的、或为此放弃了的是否都是值得的呢？为了得到，我们曾选择放弃、背叛、谎言、隐忍。。。可是那短暂的得到又会怎样那，幸福和快乐只是慢慢的淹没在自责、愧疚和恐惧中！<br>26、也许每个人心中都有一个风筝，无论它意味着什么，让我们勇敢地追。<br>27、我们每个人或多或少都在年幼的时候做过一些让自己今后感到羞愧的事，这些事可能如影子一般伴随自己一生，让你只能低着头去看它。可是时光不会掉头，自己尽力的弥补，何尝不是一种自我拯救呢？<br>28、我追。一个成年人在一群尖叫的孩子中奔跑，但我不在乎。我追。风拂过我的脸庞，我唇上挂着一个像潘杰希尔峡谷那样大大的微笑。<br>29、爸爸常说，甚至连伤害坏人也是不对的，因为他们不知道什么是好的，还因为坏人有时也会变好。<br>30、安静是祥和，是平静，是降下生命音量的旋钮。沉默是把那个按钮关掉，把它旋下，全部旋掉。<br>31、“我骗过你吗，阿米尔少爷？”，刹那间我决定跟他开开玩笑：“我不知道，你会骗我吗？”，“我宁愿吃泥巴也不骗你，”他带着愤愤的表情说，“真的吗？你会那样做？”，他疑惑地看了我一眼：“做什么？”，“如果我让你吃泥巴，你会吃吗？”我说，我知道自己这样很残忍，“如果你要求，我会的，”，“你是否会让我这么做，你会吗，阿米尔少爷？”，我勉强露出一个笑脸，“别傻了，哈桑，你知道我不会的，”，哈桑报我以微笑，不过他并非强颜欢笑，“我知道，”他说，这就是那些一诺千金的人的作风，以为别人也和他们一样。<br>32、许多年过去了，人们说陈年旧事可以被埋葬，然而我终于明白这是错的，因为往事会自行爬上来。<br>33、我站在它下面，想起我们无数次爬上去，坐在枝桠上，双腿摇晃，斑驳的阳光穿越过树叶，在我们脸上投射出交错的光和影。<br>34、我梦到花儿再次在喀布尔街头盛开，音乐再次在茶屋响起，风筝再次在天空飞翔。我梦到有朝一日，你会回到喀布尔，重访这片我们儿时的土地。如果你回来，你会发现有个忠诚的老朋友在等着你。<br>35、索拉博的沉默既不是来自世事洞明之后的泰然自若，也并非由于他选择了沉默不语来秉持自己的信念和表达抗议，而是对生活曾有过的黑暗忍气吞声地照单全收。<br>36、“他……他跟你怎么说起我们？”，“他说你是他一生最好的朋友，”，（当阿米尔背叛和哈桑的友情时，哈桑仍认为他是他最好的朋友，一直）<br>37、但对我而言，这是唯一的机会，让我可以成为一个被注目而非仅仅被看到，被聆听而非仅仅被听到的人。<br>38、也许我在那儿站了不到一分钟，但时至今日，那依旧是我生命中最漫长的一分钟，时间一秒一秒过去，而一秒与一秒之间，似乎隔着永恒，空气变得沉闷，潮湿，甚至凝固，我呼吸艰难。<br>39、我看着爸爸的轿车驶离路边，带走那个人，那个平生说出的第一个字是我名字的人。<br>40、我对他脑海盘桓的念头常常一无所知，可是我在他面前怎么就像一本打开的书？到学校上学的人是我，会读书写字的人是我，聪明伶俐的也是我，哈桑虽然看不懂一年级的课本，却能看穿我，这让人不安，可是有人永远对你的需求了如指掌，毕竟也叫人宽心。<br>41、我们默默无声，但并非因为我们无话可说，而是因为我们之间无需交谈——那些自出世就认识、喝着同样奶水长大的人就是这样。<br>42、《可兰经》的经文在屋子里还回荡，我想起爸爸在俾路支赤手空拳和黑熊搏斗那个古老的传说，爸爸毕生都在与熊搏斗，痛失正值芳龄的妻子；独自把儿子抚养成人；离开他深爱的家园，他的祖国；遭受贫穷，屈辱，而到了最后，终于来了一只他无法打败的熊，但即使这样，他也绝不妥协。<br>43、许多年过去了，人们说陈年旧事可以被埋葬，然而我终于明白这是错的，因为往事会自行爬上来，回首前尘，我意识到在过去二十六里，自己始终窥视着荒芜的小径。</p>
</blockquote>
]]></content>
      <categories>
        <category>书摘</category>
      </categories>
      <tags>
        <tag>书摘</tag>
      </tags>
  </entry>
</search>
